{"version":3,"sources":["../../../src/common/framework/params_builder.ts"],"names":["publicParamsEquals","assert","poptions","name","values","iter","makeReusableIterable","value","pbool","params","ParamsBuilder","Symbol","iterator","paramSpecs","combine","newParams","a","b","mergeParams","expand","expander","filter","pred","p","unless","x","exclude","excludeArray","Array","from","every","e","generatorFn","key","Object","keys"],"mappings":"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","sourcesContent":["import { CaseParams, CaseParamsIterable, publicParamsEquals } from './params_utils.js';\nimport { assert } from './util/util.js';\n\n// https://stackoverflow.com/a/56375136\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void\n  ? I\n  : never;\ntype CheckForUnion<T, TErr, TOk> = [T] extends [UnionToIntersection<T>] ? TOk : TErr;\n\ntype CheckForStringLiteralType<T, TOk> = string extends T ? void : CheckForUnion<T, void, TOk>;\n\nexport function poptions<Name extends string, V>(\n  name: Name,\n  values: Iterable<V>\n): CheckForStringLiteralType<Name, Iterable<{ [name in Name]: V }>> {\n  const iter = makeReusableIterable(function* () {\n    for (const value of values) {\n      yield { [name]: value };\n    }\n  });\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  return iter as any;\n}\n\nexport function pbool<Name extends string>(\n  name: Name\n): CheckForStringLiteralType<Name, Iterable<{ [name in Name]: boolean }>> {\n  return poptions(name, [false, true]);\n}\n\nexport function params(): ParamsBuilder<{}> {\n  return new ParamsBuilder();\n}\n\nexport class ParamsBuilder<A extends {}> implements CaseParamsIterable {\n  private paramSpecs: CaseParamsIterable = [{}];\n\n  [Symbol.iterator](): Iterator<A> {\n    const iter: Iterator<CaseParams> = this.paramSpecs[Symbol.iterator]();\n    return iter as Iterator<A>;\n  }\n\n  combine<B extends {}>(newParams: Iterable<B>): ParamsBuilder<Merged<A, B>> {\n    const paramSpecs = this.paramSpecs as Iterable<A>;\n    this.paramSpecs = makeReusableIterable(function* () {\n      for (const a of paramSpecs) {\n        for (const b of newParams) {\n          yield mergeParams(a, b);\n        }\n      }\n    }) as CaseParamsIterable;\n    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n    return this as any;\n  }\n\n  expand<B extends {}>(expander: (_: A) => Iterable<B>): ParamsBuilder<Merged<A, B>> {\n    const paramSpecs = this.paramSpecs as Iterable<A>;\n    this.paramSpecs = makeReusableIterable(function* () {\n      for (const a of paramSpecs) {\n        for (const b of expander(a)) {\n          yield mergeParams(a, b);\n        }\n      }\n    }) as CaseParamsIterable;\n    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n    return this as any;\n  }\n\n  filter(pred: (_: A) => boolean): ParamsBuilder<A> {\n    const paramSpecs = this.paramSpecs as Iterable<A>;\n    this.paramSpecs = makeReusableIterable(function* () {\n      for (const p of paramSpecs) {\n        if (pred(p)) {\n          yield p;\n        }\n      }\n    });\n    return this;\n  }\n\n  unless(pred: (_: A) => boolean): ParamsBuilder<A> {\n    return this.filter(x => !pred(x));\n  }\n\n  exclude(exclude: CaseParamsIterable): ParamsBuilder<A> {\n    const excludeArray = Array.from(exclude);\n    const paramSpecs = this.paramSpecs;\n    this.paramSpecs = makeReusableIterable(function* () {\n      for (const p of paramSpecs) {\n        if (excludeArray.every(e => !publicParamsEquals(p, e))) {\n          yield p;\n        }\n      }\n    });\n    return this;\n  }\n}\n\n// If you create an Iterable by calling a generator function (e.g. in IIFE), it is exhausted after\n// one use. This just wraps a generator function in an object so it be iterated multiple times.\nfunction makeReusableIterable<P>(generatorFn: () => Generator<P>): Iterable<P> {\n  return { [Symbol.iterator]: generatorFn };\n}\n\ntype ValueTypeForKeyOfMergedType<A, B, Key extends keyof A | keyof B> = Key extends keyof A\n  ? Key extends keyof B\n    ? void // Key is in both types\n    : A[Key] // Key is only in A\n  : Key extends keyof B\n  ? B[Key] // Key is only in B\n  : void; // Key is in neither type (not possible)\n\ntype Merged<A, B> = keyof A & keyof B extends never\n  ? string extends keyof A | keyof B\n    ? never // (keyof A | keyof B) == string, which is too broad\n    : {\n        [Key in keyof A | keyof B]: ValueTypeForKeyOfMergedType<A, B, Key>;\n      }\n  : never; // (keyof A & keyof B) is not empty, so they overlapped\n\nfunction mergeParams<A extends {}, B extends {}>(a: A, b: B): Merged<A, B> {\n  for (const key of Object.keys(a)) {\n    assert(!(key in b), 'Duplicate key: ' + key);\n  }\n  return { ...a, ...b } as Merged<A, B>;\n}\n"],"file":"params_builder.js"}