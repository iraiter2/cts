{"version":3,"sources":["../../../../src/common/framework/query/parseQuery.ts"],"names":["badParamValueChars","paramKeyIsPublic","assert","TestQueryMultiFile","TestQueryMultiTest","TestQueryMultiCase","TestQuerySingleCase","kBigSeparator","kWildcard","kPathSeparator","kParamSeparator","validQueryPart","parseQuery","s","parseQueryImpl","ex","message","decodeURIComponent","suite","fileString","testString","paramsString","split","undefined","parts","file","wildcard","filePathHasWildcard","parseBigPart","test","testPathHasWildcard","length","paramsParts","paramsHasWildcard","params","paramPart","k","v","parseSingleParam","kExampleQueries","separator","endsWithWildcard","i","part","entries","indexOf","paramSubstring","substring","parseSingleParamValue","JSON","parse"],"mappings":";;;;AAAA,SAGEA,kBAHF,EAIEC,gBAJF,QAKO,oBALP;AAMA,SAASC,MAAT,QAAuB,iBAAvB;AAEA,SAEEC,kBAFF,EAGEC,kBAHF,EAIEC,kBAJF,EAKEC,mBALF,QAMO,YANP;AAOA,SAASC,aAAT,EAAwBC,SAAxB,EAAmCC,cAAnC,EAAmDC,eAAnD,QAA0E,iBAA1E;AACA,SAASC,cAAT,QAA+B,qBAA/B;AAEA,OAAO,SAASC,UAAT,CAAoBC,CAApB,EAA0C;AAC/C,MAAI;AACF,WAAOC,cAAc,CAACD,CAAD,CAArB;AACD,GAFD,CAEE,OAAOE,EAAP,EAAW;AACXA,IAAAA,EAAE,CAACC,OAAH,IAAc,aAAaH,CAA3B;AACA,UAAME,EAAN;AACD;AACF;;AAED,SAASD,cAAT,CAAwBD,CAAxB,EAA8C;AAC5C;AACAA,EAAAA,CAAC,GAAGI,kBAAkB,CAACJ,CAAD,CAAtB,CAF4C,CAI5C;;AACA,QAAM,CAACK,KAAD,EAAQC,UAAR,EAAoBC,UAApB,EAAgCC,YAAhC,IAAgDR,CAAC,CAACS,KAAF,CAAQf,aAAR,EAAuB,CAAvB,CAAtD;AACAL,EAAAA,MAAM,CAACiB,UAAU,KAAKI,SAAhB,EAA4B,wCAAuChB,aAAc,EAAjF,CAAN;AAEA,QAAM;AAAEiB,IAAAA,KAAK,EAAEC,IAAT;AAAeC,IAAAA,QAAQ,EAAEC;AAAzB,MAAiDC,YAAY,CAACT,UAAD,EAAaV,cAAb,CAAnE;;AAEA,MAAIW,UAAU,KAAKG,SAAnB,EAA8B;AAC5B;AACArB,IAAAA,MAAM,CACJyB,mBADI,EAEH,qCAAoCnB,SAAU;UAC3CC,cAAe,GAAED,SAAU,iCAAgCD,aAAc,GAAEC,SAAU,IAHrF,CAAN;AAKA,WAAO,IAAIL,kBAAJ,CAAuBe,KAAvB,EAA8BO,IAA9B,CAAP;AACD;;AACDvB,EAAAA,MAAM,CAAC,CAACyB,mBAAF,EAAwB,YAAWnB,SAAU,yCAA7C,CAAN;AAEA,QAAM;AAAEgB,IAAAA,KAAK,EAAEK,IAAT;AAAeH,IAAAA,QAAQ,EAAEI;AAAzB,MAAiDF,YAAY,CAACR,UAAD,EAAaX,cAAb,CAAnE;;AAEA,MAAIY,YAAY,KAAKE,SAArB,EAAgC;AAC9B;AACArB,IAAAA,MAAM,CACJ4B,mBADI,EAEH,qCAAoCtB,SAAU;UAC3CC,cAAe,GAAED,SAAU,iCAAgCD,aAAc,GAAEC,SAAU,IAHrF,CAAN;AAKAN,IAAAA,MAAM,CAACuB,IAAI,CAACM,MAAL,GAAc,CAAf,EAAkB,8CAAlB,CAAN;AACA,WAAO,IAAI3B,kBAAJ,CAAuBc,KAAvB,EAA8BO,IAA9B,EAAoCI,IAApC,CAAP;AACD,GAhC2C,CAkC5C;;;AACA3B,EAAAA,MAAM,CAAC,CAAC4B,mBAAF,EAAwB,YAAWtB,SAAU,yCAA7C,CAAN;AAEA,QAAM;AAAEgB,IAAAA,KAAK,EAAEQ,WAAT;AAAsBN,IAAAA,QAAQ,EAAEO;AAAhC,MAAsDL,YAAY,CACtEP,YADsE,EAEtEX,eAFsE,CAAxE;AAKAR,EAAAA,MAAM,CAAC2B,IAAI,CAACE,MAAL,GAAc,CAAf,EAAkB,8CAAlB,CAAN;AAEA,QAAMG,MAAoB,GAAG,EAA7B;;AACA,OAAK,MAAMC,SAAX,IAAwBH,WAAxB,EAAqC;AACnC,UAAM,CAACI,CAAD,EAAIC,CAAJ,IAASC,gBAAgB,CAACH,SAAD,CAA/B;AACAjC,IAAAA,MAAM,CAACS,cAAc,CAACkB,IAAf,CAAoBO,CAApB,CAAD,EAAyB,gCAAgCzB,cAAzD,CAAN;AACAuB,IAAAA,MAAM,CAACE,CAAD,CAAN,GAAYC,CAAZ;AACD;;AACD,MAAIJ,iBAAJ,EAAuB;AACrB,WAAO,IAAI5B,kBAAJ,CAAuBa,KAAvB,EAA8BO,IAA9B,EAAoCI,IAApC,EAA0CK,MAA1C,CAAP;AACD,GAFD,MAEO;AACL,WAAO,IAAI5B,mBAAJ,CAAwBY,KAAxB,EAA+BO,IAA/B,EAAqCI,IAArC,EAA2CK,MAA3C,CAAP;AACD;AACF,C,CAED;;;AACA,MAAMK,eAAe,GAAI;QACjBhC,aAAc,IAAGE,cAAe,IAAGA,cAAe,GAAED,SAAU;QAC9DD,aAAc,IAAGE,cAAe,IAAGA,cAAe,IAAGF,aAAc,GAAEC,SAAU,EAFvF;;AAIA,SAASoB,YAAT,CACEf,CADF,EAEE2B,SAFF,EAG0C;AACxC,MAAI3B,CAAC,KAAK,EAAV,EAAc;AACZ,WAAO;AAAEW,MAAAA,KAAK,EAAE,EAAT;AAAaE,MAAAA,QAAQ,EAAE;AAAvB,KAAP;AACD;;AACD,QAAMF,KAAK,GAAGX,CAAC,CAACS,KAAF,CAAQkB,SAAR,CAAd;AAEA,MAAIC,gBAAgB,GAAG,KAAvB;;AACA,OAAK,MAAM,CAACC,CAAD,EAAIC,IAAJ,CAAX,IAAwBnB,KAAK,CAACoB,OAAN,EAAxB,EAAyC;AACvC,QAAIF,CAAC,KAAKlB,KAAK,CAACO,MAAN,GAAe,CAAzB,EAA4B;AAC1BU,MAAAA,gBAAgB,GAAGE,IAAI,KAAKnC,SAA5B;AACD;;AACDN,IAAAA,MAAM,CACJyC,IAAI,CAACE,OAAL,CAAarC,SAAb,MAA4B,CAAC,CAA7B,IAAkCiC,gBAD9B,EAEH,YAAWjC,SAAU,+CAA8C+B,eAAgB,GAFhF,CAAN;AAID;;AACD,MAAIE,gBAAJ,EAAsB;AACpB;AACAjB,IAAAA,KAAK,CAACO,MAAN,GAAeP,KAAK,CAACO,MAAN,GAAe,CAA9B;AACD;;AACD,SAAO;AAAEP,IAAAA,KAAF;AAASE,IAAAA,QAAQ,EAAEe;AAAnB,GAAP;AACD;;AAED,SAASH,gBAAT,CAA0BQ,cAA1B,EAA2E;AACzE5C,EAAAA,MAAM,CAAC4C,cAAc,KAAK,EAApB,EAAwB,iEAAxB,CAAN;AACA,QAAMJ,CAAC,GAAGI,cAAc,CAACD,OAAf,CAAuB,GAAvB,CAAV;AACA3C,EAAAA,MAAM,CAACwC,CAAC,KAAK,CAAC,CAAR,EAAW,4CAAX,CAAN;AACA,QAAMN,CAAC,GAAGU,cAAc,CAACC,SAAf,CAAyB,CAAzB,EAA4BL,CAA5B,CAAV;AACAxC,EAAAA,MAAM,CAACD,gBAAgB,CAACmC,CAAD,CAAjB,EAAsB,qDAAtB,CAAN;AACA,QAAMC,CAAC,GAAGS,cAAc,CAACC,SAAf,CAAyBL,CAAC,GAAG,CAA7B,CAAV;AACA,SAAO,CAACN,CAAD,EAAIY,qBAAqB,CAACX,CAAD,CAAzB,CAAP;AACD;;AAED,SAASW,qBAAT,CAA+BnC,CAA/B,EAAyD;AACvDX,EAAAA,MAAM,CACJ,CAACF,kBAAkB,CAAC6B,IAAnB,CAAwBhB,CAAxB,CADG,EAEH,8BAA6Bb,kBAAmB,UAASa,CAAE,EAFxD,CAAN;AAIA,SAAOA,CAAC,KAAK,WAAN,GAAoBU,SAApB,GAAgC0B,IAAI,CAACC,KAAL,CAAWrC,CAAX,CAAvC;AACD","sourcesContent":["import {\n  CaseParamsRW,\n  ParamArgument,\n  badParamValueChars,\n  paramKeyIsPublic,\n} from '../params_utils.js';\nimport { assert } from '../util/util.js';\n\nimport {\n  TestQuery,\n  TestQueryMultiFile,\n  TestQueryMultiTest,\n  TestQueryMultiCase,\n  TestQuerySingleCase,\n} from './query.js';\nimport { kBigSeparator, kWildcard, kPathSeparator, kParamSeparator } from './separators.js';\nimport { validQueryPart } from './validQueryPart.js';\n\nexport function parseQuery(s: string): TestQuery {\n  try {\n    return parseQueryImpl(s);\n  } catch (ex) {\n    ex.message += '\\n  on: ' + s;\n    throw ex;\n  }\n}\n\nfunction parseQueryImpl(s: string): TestQuery {\n  // Undo encodeURIComponentSelectively\n  s = decodeURIComponent(s);\n\n  // bigParts are: suite, group, test, params (note kBigSeparator could appear in params)\n  const [suite, fileString, testString, paramsString] = s.split(kBigSeparator, 4);\n  assert(fileString !== undefined, `filter string must have at least one ${kBigSeparator}`);\n\n  const { parts: file, wildcard: filePathHasWildcard } = parseBigPart(fileString, kPathSeparator);\n\n  if (testString === undefined) {\n    // Query is file-level\n    assert(\n      filePathHasWildcard,\n      `File-level query without wildcard ${kWildcard}. Did you want a file-level query \\\n(append ${kPathSeparator}${kWildcard}) or test-level query (append ${kBigSeparator}${kWildcard})?`\n    );\n    return new TestQueryMultiFile(suite, file);\n  }\n  assert(!filePathHasWildcard, `Wildcard ${kWildcard} must be at the end of the query string`);\n\n  const { parts: test, wildcard: testPathHasWildcard } = parseBigPart(testString, kPathSeparator);\n\n  if (paramsString === undefined) {\n    // Query is test-level\n    assert(\n      testPathHasWildcard,\n      `Test-level query without wildcard ${kWildcard}; did you want a test-level query \\\n(append ${kPathSeparator}${kWildcard}) or case-level query (append ${kBigSeparator}${kWildcard})?`\n    );\n    assert(file.length > 0, 'File part of test-level query was empty (::)');\n    return new TestQueryMultiTest(suite, file, test);\n  }\n\n  // Query is case-level\n  assert(!testPathHasWildcard, `Wildcard ${kWildcard} must be at the end of the query string`);\n\n  const { parts: paramsParts, wildcard: paramsHasWildcard } = parseBigPart(\n    paramsString,\n    kParamSeparator\n  );\n\n  assert(test.length > 0, 'Test part of case-level query was empty (::)');\n\n  const params: CaseParamsRW = {};\n  for (const paramPart of paramsParts) {\n    const [k, v] = parseSingleParam(paramPart);\n    assert(validQueryPart.test(k), 'param key names must match ' + validQueryPart);\n    params[k] = v;\n  }\n  if (paramsHasWildcard) {\n    return new TestQueryMultiCase(suite, file, test, params);\n  } else {\n    return new TestQuerySingleCase(suite, file, test, params);\n  }\n}\n\n// webgpu:a,b,* or webgpu:a,b,c:*\nconst kExampleQueries = `\\\nwebgpu${kBigSeparator}a${kPathSeparator}b${kPathSeparator}${kWildcard} or \\\nwebgpu${kBigSeparator}a${kPathSeparator}b${kPathSeparator}c${kBigSeparator}${kWildcard}`;\n\nfunction parseBigPart(\n  s: string,\n  separator: typeof kParamSeparator | typeof kPathSeparator\n): { parts: string[]; wildcard: boolean } {\n  if (s === '') {\n    return { parts: [], wildcard: false };\n  }\n  const parts = s.split(separator);\n\n  let endsWithWildcard = false;\n  for (const [i, part] of parts.entries()) {\n    if (i === parts.length - 1) {\n      endsWithWildcard = part === kWildcard;\n    }\n    assert(\n      part.indexOf(kWildcard) === -1 || endsWithWildcard,\n      `Wildcard ${kWildcard} must be complete last part of a path (e.g. ${kExampleQueries})`\n    );\n  }\n  if (endsWithWildcard) {\n    // Remove the last element of the array (which is just the wildcard).\n    parts.length = parts.length - 1;\n  }\n  return { parts, wildcard: endsWithWildcard };\n}\n\nfunction parseSingleParam(paramSubstring: string): [string, ParamArgument] {\n  assert(paramSubstring !== '', 'Param in a query must not be blank (is there a trailing comma?)');\n  const i = paramSubstring.indexOf('=');\n  assert(i !== -1, 'Param in a query must be of form key=value');\n  const k = paramSubstring.substring(0, i);\n  assert(paramKeyIsPublic(k), 'Param in a query must not be private (start with _)');\n  const v = paramSubstring.substring(i + 1);\n  return [k, parseSingleParamValue(v)];\n}\n\nfunction parseSingleParamValue(s: string): ParamArgument {\n  assert(\n    !badParamValueChars.test(s),\n    `param value must not match ${badParamValueChars} - was ${s}`\n  );\n  return s === 'undefined' ? undefined : JSON.parse(s);\n}\n"],"file":"parseQuery.js"}