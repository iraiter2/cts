{"version":3,"sources":["../../../../src/webgpu/util/texture/layout.ts"],"names":["assert","unreachable","kTextureFormatInfo","align","isAligned","kBytesPerRowAlignment","kBufferCopyAlignment","kDefaultLayoutOptions","mipLevel","bytesPerRow","undefined","rowsPerImage","getMipSizePassthroughLayers","dimension","size","shiftMinOne","n","Math","max","getTextureCopyLayout","format","options","mipSize","blockWidth","blockHeight","bytesPerBlock","minBytesPerRow","alignedMinBytesPerRow","bytesPerSlice","sliceSize","byteLength","fillTextureDataWithTexelValue","texelValue","outputBuffer","texelValueBytes","Uint8Array","outputTexelValueBytes","slice","row","col","byteOffset","set","createTextureUploadBuffer","device","buffer","mapping","createBufferMapped","usage","GPUBufferUsage","COPY_SRC","unmap"],"mappings":"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","sourcesContent":["import { assert, unreachable } from '../../../common/framework/util/util.js';\nimport { kTextureFormatInfo } from '../../capability_info.js';\nimport { align, isAligned } from '../math.js';\n\nexport const kBytesPerRowAlignment = 256;\nexport const kBufferCopyAlignment = 4;\n\nexport interface LayoutOptions {\n  mipLevel: number;\n  bytesPerRow?: number;\n  rowsPerImage?: number;\n}\n\nconst kDefaultLayoutOptions = { mipLevel: 0, bytesPerRow: undefined, rowsPerImage: undefined };\n\nexport function getMipSizePassthroughLayers(\n  dimension: GPUTextureDimension,\n  size: [number, number, number],\n  mipLevel: number\n): [number, number, number] {\n  const shiftMinOne = (n: number) => Math.max(1, n >> mipLevel);\n  switch (dimension) {\n    case '1d':\n      assert(size[2] === 1);\n      return [shiftMinOne(size[0]), size[1], size[2]];\n    case '2d':\n      return [shiftMinOne(size[0]), shiftMinOne(size[1]), size[2]];\n    case '3d':\n      return [shiftMinOne(size[0]), shiftMinOne(size[1]), shiftMinOne(size[2])];\n    default:\n      unreachable();\n  }\n}\n\nexport function getTextureCopyLayout(\n  format: GPUTextureFormat,\n  dimension: GPUTextureDimension,\n  size: [number, number, number],\n  options: LayoutOptions = kDefaultLayoutOptions\n): {\n  bytesPerBlock: number;\n  byteLength: number;\n  minBytesPerRow: number;\n  bytesPerRow: number;\n  rowsPerImage: number;\n  mipSize: [number, number, number];\n} {\n  const { mipLevel } = options;\n  let { bytesPerRow, rowsPerImage } = options;\n\n  const mipSize = getMipSizePassthroughLayers(dimension, size, mipLevel);\n\n  const { blockWidth, blockHeight, bytesPerBlock } = kTextureFormatInfo[format];\n  assert(!!bytesPerBlock && !!blockWidth && !!blockHeight);\n\n  assert(isAligned(mipSize[0], blockWidth));\n  const minBytesPerRow = (mipSize[0] / blockWidth) * bytesPerBlock;\n  const alignedMinBytesPerRow = align(minBytesPerRow, kBytesPerRowAlignment);\n  if (bytesPerRow !== undefined) {\n    assert(bytesPerRow >= alignedMinBytesPerRow);\n    assert(isAligned(bytesPerRow, kBytesPerRowAlignment));\n  } else {\n    bytesPerRow = alignedMinBytesPerRow;\n  }\n\n  if (rowsPerImage !== undefined) {\n    assert(rowsPerImage >= mipSize[1]);\n  } else {\n    rowsPerImage = mipSize[1];\n  }\n\n  assert(isAligned(rowsPerImage, blockHeight));\n  const bytesPerSlice = bytesPerRow * (rowsPerImage / blockHeight);\n  const sliceSize =\n    bytesPerRow * (mipSize[1] / blockHeight - 1) + bytesPerBlock * (mipSize[0] / blockWidth);\n  const byteLength = bytesPerSlice * (mipSize[2] - 1) + sliceSize;\n\n  return {\n    bytesPerBlock,\n    byteLength: align(byteLength, kBufferCopyAlignment),\n    minBytesPerRow,\n    bytesPerRow,\n    rowsPerImage,\n    mipSize,\n  };\n}\n\nexport function fillTextureDataWithTexelValue(\n  texelValue: ArrayBuffer,\n  format: GPUTextureFormat,\n  dimension: GPUTextureDimension,\n  outputBuffer: ArrayBuffer,\n  size: [number, number, number],\n  options: LayoutOptions = kDefaultLayoutOptions\n): void {\n  const { blockWidth, blockHeight, bytesPerBlock } = kTextureFormatInfo[format];\n  assert(!!bytesPerBlock && !!blockWidth && !!blockHeight);\n  assert(bytesPerBlock === texelValue.byteLength);\n\n  const { byteLength, rowsPerImage, bytesPerRow } = getTextureCopyLayout(\n    format,\n    dimension,\n    size,\n    options\n  );\n\n  assert(byteLength <= outputBuffer.byteLength);\n\n  const mipSize = getMipSizePassthroughLayers(dimension, size, options.mipLevel);\n\n  const texelValueBytes = new Uint8Array(texelValue);\n  const outputTexelValueBytes = new Uint8Array(outputBuffer);\n  for (let slice = 0; slice < mipSize[2]; ++slice) {\n    for (let row = 0; row < mipSize[1]; row += blockHeight) {\n      for (let col = 0; col < mipSize[0]; col += blockWidth) {\n        const byteOffset =\n          slice * rowsPerImage * bytesPerRow + row * bytesPerRow + col * texelValue.byteLength;\n        outputTexelValueBytes.set(texelValueBytes, byteOffset);\n      }\n    }\n  }\n}\n\nexport function createTextureUploadBuffer(\n  texelValue: ArrayBuffer,\n  device: GPUDevice,\n  format: GPUTextureFormat,\n  dimension: GPUTextureDimension,\n  size: [number, number, number],\n  options: LayoutOptions = kDefaultLayoutOptions\n): {\n  buffer: GPUBuffer;\n  bytesPerRow: number;\n  rowsPerImage: number;\n} {\n  const { byteLength, bytesPerRow, rowsPerImage, bytesPerBlock } = getTextureCopyLayout(\n    format,\n    dimension,\n    size,\n    options\n  );\n\n  const [buffer, mapping] = device.createBufferMapped({\n    size: byteLength,\n    usage: GPUBufferUsage.COPY_SRC,\n  });\n\n  assert(texelValue.byteLength === bytesPerBlock);\n  fillTextureDataWithTexelValue(texelValue, format, dimension, mapping, size, options);\n  buffer.unmap();\n\n  return {\n    buffer,\n    bytesPerRow,\n    rowsPerImage,\n  };\n}\n"],"file":"layout.js"}